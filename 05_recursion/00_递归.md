# 递归

递归就在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解。

递归的逻辑中一般有两个重要概念：

1. 递归边界(base case)
2. 递归式(或称递归调用)


## 全排列

全排列(Full Permutation)：一般把1~n这n个整数按某个顺序摆放的结果称为这n个整数的一个排列，而全排列指这n个整数能形成的所有排列。

对于按字典序从小到大的顺序输出1~n的全排列，其中(a1,a2,...,an)的字典序小于(b1,b2,...,bn)是指存在一个i，使得a1=b1, a2=b2, ..., ai-1=bi-1, ai<bi成立。

从递归的角度，输出1~n这n个整数的全排列，可以被分为若干个子问题：“输出以1开头的全排列”，“输出以2开头的全排列”，……，“输出以n开头的全排列。

> 不妨设定一个数组P，用来存放当前的排列；再设定一个散列数组hashTable，其中hashTable[x]当整数x已经在数组P中时为 `true`。
>
> 现在按顺序往P的第1位到第n位中填入数字。不妨假定当前已经填好了P[1]~P[index-1]，正准备填P[index]。
>
> 显然需要枚举1~n，如果当前枚举的数字x还没有在P[1]~P[index-1]中(即hashTable[x]=false)，那么就把它填入P[index]，同时把hashTable[x]置为true，然后去处理P的第index+1位(即进行递归)；而当递归完成时，再将hashTable[x]还原为false，以便让P[index]填下一个数字。
>
> 递归边界。当index达到n+1时，说明P的1~n位都已经填好了，此时可以把数组P输出，表示生成了一个排列，然后直接return即可。
